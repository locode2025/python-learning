# リストとタプルとセット

ここまで、数値や文字の演算と、その演算結果を変数に格納することを学びました。プログラムの数値型、文字列型に触れましたが、Python には数値型、文字列型の他にも型が存在します。それではPythonの型を見ていきましょう！

## 1. 組み込み型

### 組み込み型とは

Python では、データに **「型」** という概念があり、値の種類によって分類されます。  
データ型を正しく理解することで、適切な計算やデータの操作ができるようになります。

Python にはさまざまなデータ型がありますが、Python に搭載されている組み込み型と呼ばれる基本的な型は次のとおりです。

| データ型 | 説明 | 例 |
| -- | -- | -- |
| `int` | **整数型**（小数なし） | `10, -3, 1000` |
| `float` | **浮動小数点数型**（小数あり） | `3.14, -0.5, 2.0` |
| `str` | **文字列型**（テキスト）  | `"Hello", 'Python'` |
| `bool` | **真偽値型**（真 or 偽） | `True, False` |
| `list` | **リスト型**（複数の値を格納） | `[1, 2, 3]` |
| `tuple` | **タプル型**（変更不可のリスト） | `(1, 2, 3)` |
| `dict` | **辞書型**（キーと値のペア） | `{"name": "Alice", "age": 25}` |

Python では、**変数に値を代入すると、その値のデータ型が自動的に決まります**。

**プログラム：**
```python
x = 10      # 整数型 (int)
y = 3.14    # 浮動小数点数型 (float)
name = "Alice"  # 文字列型 (str)

print(type(x))
print(type(y))
print(type(name))
```

**出力：**
```bash
<class 'int'>
<class 'float'>
<class 'str'>
```

## 2. リスト

プログラムを作る上で「変数」は非常に重要な概念です。変数を使うことで、数値や文字列を一時的に記憶し、必要に応じて計算や処理を行えます。

例えば、次のように **score1** や **score2** に数値を入れ、合計を計算できます。

**プログラム：**
```python
score1 = 85
score2 = 90
total = score1 + score2
print(total)
```

**出力：**
```bash
175
```

このように、変数を使えば値を保存し、計算に活用できます。

しかし、プログラムが複雑になると、変数だけでデータを扱うのは大変になります。例えば、次のように10人分のテストの点数を管理する場合を考えましょう。

```python
score1 = 85
score2 = 90
score3 = 78
score4 = 92
score5 = 88
score6 = 76
score7 = 95
score8 = 89
score9 = 84
score10 = 91
```

この状態では、「10人以上になったらどうするのか？」 「全員の平均点を求めるとき、どう計算するのか？」 という問題が発生します。

変数だけでデータを管理するのは手間がかかり、拡張性に乏しいのです。

そこで登場するのが、「データの集まり（コンテナ）」です。Pythonには、**リスト**、**ディクショナリ**、**タプル**、**セット** という便利なデータ構造が用意されています。

例えば、リストを使うと、先ほどの10人分のスコアを簡単に管理できます。そして、リストを使えば、平均点も簡単に計算できます。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88, 76, 95, 89, 84, 91]
average = sum(scores) / len(scores)
print(average)
```

**出力：**
```bash
86.8
```

このように、データを「まとめて管理する」ことで、より柔軟で便利なプログラムが作れるようになります。

この章では、Pythonの「データの集まり（コンテナ）」について詳しく学んでいきましょう。

プログラムを作る上で、複数のデータをまとめて管理することは非常に重要です。Pythonでは、データの集まりを扱うために「リスト」というデータ構造が用意されています。

### リストの特徴

リストは、複数の値を順番に並べて格納できるデータ構造 です。
リストを使うことで、一つの変数で複数のデータをまとめて扱う ことができます。

例えば、10人分のテストの点数をリストで表すと、次のようになります。

```python
scores = [85, 90, 78, 92, 88, 76, 95, 89, 84, 91]
```

リストには次のような特徴があります。

!!! note "① 順番（インデックス）がある"

    リストのデータには「インデックス（index）」と呼ばれる番号が振られており、順番にアクセスできる ようになっています。
    Pythonのリストは **0から始まるインデックス** を持っています。

    | インデックス | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
    | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
    | 値（スコア）| 85 | 90 | 78 | 92 | 88 | 76 | 95 | 89 | 84 | 91 |

    例えば、1番目のスコア（**85**）を取得するには、`scores[0]` を使います。

    **プログラム：**
    ```python
    print(scores[0])
    ```

    **出力：**
    ```bash
    85
    ```

!!! note "② 異なるデータ型を混ぜて格納できる"

    リストには、整数・小数・文字列など、異なるデータ型を混ぜて格納することが可能 です。

    ```python
    data = [100, "Python", 3.14, True]
    ```

!!! note "③ 要素の追加・変更・削除ができる"

    リストは、一度作成した後でも、データの追加・変更・削除が可能 です。
    例えば、新しいスコアを追加したり、既存のスコアを変更したりできます。

では、リストの作成方法について詳しく解説していきます。

---

### リストの作成

__1. リストを作る基本的な方法__

実際にリストを作成する方法を詳しく見ていきましょう。リストを作るには、角かっこ（`[]`）を使って、データをカンマ（`,`）で区切って並べる だけです。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
print(scores)
```

**出力：**
```bash
[85, 90, 78, 92, 88]
```

---

__2. 空のリストを作る方法__

最初は中身がないリストを作って、あとからデータを追加したい場合もあります。
その場合は、空の角かっこ `[]` を使う か、`list()` を使います。

```python
empty_list1 = []  # 空のリスト
empty_list2 = list()  # こちらも空のリスト

print(empty_list1)  # []
print(empty_list2)  # []
```

どちらの方法でも、「最初はデータが空のリスト」を作成できる ので、状況に応じて使い分けましょう。

---

__3. 異なるデータ型を混ぜたリスト__

リストには、整数（**int**）、小数（**float**）、文字列（**str**）、真偽値（**bool**）など、さまざまなデータ型を混ぜて入れることができます。

**プログラム：**
```python
data = [100, "Python", 3.14, True]
print(data)
```

**出力：**
```bash
[100, 'Python', 3.14, True]
```

---

__3. `range()` を使ってリストを作る__

Pythonには、連続した数値を簡単にリストにする方法 があります。
それが `range()` という関数を使う方法です。

例えば、1から10までの数値をリストにするには、次のように書きます。

**プログラム：**
```python
numbers = list(range(1, 11))
print(numbers)
```

**出力：**
```bash
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

この `range(1, 11)` は、**「1 から 10 までの数値」** を順番に生成し、それを `list()` でリストに変換しています。

---

__リストの作成まとめ__

リストの作成方法には、次のようなものがあります。

| 方法 | 例 | 説明 |
| -- | -- | -- |
| 普通のリストを作る | `[85, 90, 78]` | 角かっこ `[]` を使う |
| 空のリストを作る | `[]` または `list()` | 最初にデータを入れない |
| 異なるデータ型を入れる | `[100, "Python", 3.14]` | 文字や数値を混ぜられる |
| `range()` を使う | `list(range(1, 6))` | 連続した数値のリスト |

このように、Pythonのリストは柔軟にデータを扱うことができます。

---

### リストの要素を参照

今回は、**リストの中のデータ（要素）を取り出す方法** を詳しく解説していきます。

__インデックスを使って要素を取り出す__

リストの要素を参照（取得）するには、**インデックス（index）** を使います。
Pythonのリストは、**0番目から順番に番号が振られている** ことを思い出しましょう。

例えば、以下のリストを考えます。

```python
scores = [85, 90, 78, 92, 88]
```

このリストは、次のようにインデックスが振られています。

| インデックス | 0  | 1  | 2  | 3  | 4  |
|-------------|----|----|----|----|----|
| 値（スコア）| 85 | 90 | 78 | 92 | 88 |

例えば、**2番目のスコア（インデックス1）を取得** するには、`scores[1]` と書きます。

**プログラム：**
```python
print(scores[1])
```

**出力：**
```bash
90
```

---

### リストの要素の合計と要素数の取得

今回は、リストの合計や要素数（長さ） を取得する方法を解説していきます。

__リストの要素の合計を求める__

Pythonでは、`sum()` 関数を使ってリスト内の数値の合計を求めることができます。

例えば、以下のリストの合計を計算してみましょう。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
total = sum(scores)
print(total)
```

**出力：**
```bash
433
```

---

__リストの要素数（長さ）を求める__

リストの要素数（長さ）を求めるには、`len()` 関数を使います。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
count = len(scores)
print(count)
```

**出力：**
```bash
5
```

---

__平均値を求める__

合計と要素数が分かれば、平均値も計算できます。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
average = sum(scores) / len(scores) 
print(average)
```

**出力：**
```bash
86.6
```

Pythonでは、リストの数値を使って簡単に統計的な計算ができます。
例えば、最大値や最小値も `max()` や `min()` を使って取得できます。

---

__リストの要素に対する演算のまとめ__

| 操作 | 書き方 | 説明 |
| -- | -- | -- |
| 合計を求める | `sum(scores)`  | リストの要素の合計を計算 |
| 要素数を求める | `len(scores)` | リストの要素の数（長さ）を取得 |
| 平均値を求める |  `sum(scores) / len(scores)` | 合計を要素数で割る |
| 最大値を求める | `max(scores)` | リスト内の最大値を取得 |
| 最小値を求める | `min(scores)` | リスト内の最小値を取得 |

---

### リスト要素の追加・削除・変更

リストに要素を追加・削除・変更する方法 を解説していきます。

__リストに要素を追加する__

リストに新しい要素を追加するには、`append()` や `insert()` を使います。

!!! note "`append()` で末尾に追加"
    `append()` を使うと、リストの最後 に新しい要素を追加できます。

**プログラム：**
```python
scores = [85, 90, 78]
scores.append(92)
print(scores)
```

**出力：**
```bash
[85, 90, 78, 92]
```


!!! note "`insert()` で指定位置に追加"
    `insert(位置, 値)` を使うと、リストの途中 に要素を挿入できます。

**プログラム：**
```python
scores = [85, 90, 78]
scores.insert(1, 88)
print(scores)
```

**出力：**
```bash
[85, 88, 90, 78]
```

---

__リストの要素を削除する__

リストの要素を削除する方法はいくつかあります。

!!! note "`pop()` で要素を取り出す"
    `pop()` は、リストの末尾の要素 を取り出して削除します。

**プログラム：**
```python
scores = [85, 90, 78]
last_score = scores.pop()
print(scores)
print(last_score)
```

**出力：**
```bash
[85, 90]
78
```

指定した位置 の要素を削除することもできます。

**プログラム**
```python
scores = [85, 90, 78]
scores.pop(1)
print(scores)
```

**出力：**
```bash
[85, 78]
```

!!! note "`remove()` で指定の値を削除"
    `remove(値)` を使うと、指定した値を削除 できます。※ 同じ値が複数ある場合、最初に見つかったものだけ 削除されるので注意しましょう。

**プログラム：**
```python
scores = [85, 90, 78, 90]
scores.remove(90)
print(scores)
```

**出力：**
```bash
[85, 78, 90]
```

!!! note "`del` を使う"
    `del` を使うと、特定の要素を削除できます。

**プログラム：**
```python
scores = [85, 90, 78]
del scores[1]
print(scores)
```

**出力：**
```python
[85, 78]
```

---

__リストの要素を変更する__

リストの要素は、インデックスを指定して書き換える ことができます。

**プログラム：**
```python
scores = [85, 90, 78]
scores[1] = 88
print(scores)
```

**出力：**
```bash
[85, 88, 78]
```

複数の要素をまとめて変更することも可能です。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
scores[1:3] = [80, 75]
print(scores)
```

**出力：**
```bash
[85, 80, 75, 92, 88]
```

---

__リストの要素に対する追加・変更・削除のまとめ__

| 操作 | 書き方 | 説明 |
| -- | -- | -- |
| 要素を末尾に追加 | `scores.append(92)` | リストの最後に要素を追加 |
| 指定位置に追加 | `scores.insert(1, 88)` | インデックス1に88を挿入 |
| 末尾の要素を削除 | `scores.pop()` | 最後の要素を取り出して削除 |
| 指定位置の要素を削除 | `scores.pop(1)` | インデックス1の要素を削除 |
| 指定の値を削除 | `scores.remove(90)` | 最初に見つかった90を削除 |
| 指定の要素を削除 | `del scores[1]` | インデックス1の要素を削除 |
| 要素を変更 | `scores[1] = 88` | インデックス1の値を88に変更 |
| 複数の要素を変更 | `scores[1:3] = [80, 75]` | インデックス1～2の要素を変更 |

---

### 高度な要素の指定

__マイナスのインデックスを使う__

Pythonのリストでは、負のインデックス（マイナスの番号）を使って、後ろから要素を取得する こともできます。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
print(scores[-1])
print(scores[-2])
```

**出力：**
```bash
88
92
```

マイナスのインデックスを使うと、リストの長さが分からなくても最後の要素を簡単に取得できる ので便利です。

| インデックス | -5 | -4 | -3 | -2 | -1 |
| -- | -- | -- | -- | -- | -- |
| 値（スコア）| 85 | 90 | 78 | 92 | 88 |

---

__範囲を指定して複数の要素を取得する（スライス）__

**スライス（slice）** を使うと、リストの一部をまとめて取得できます。
スライスの書き方は、以下のようになります。

```python
リスト[開始インデックス:終了インデックス]
```

例を見てみましょう。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
print(scores[1:4])
```

**出力：**
```bash
[90, 78, 92]
```

これは、**インデックス1から3までの要素を取り出す** という意味です。
（終了インデックス（4） は含まれず、**1以上4未満** の範囲になる点に注意してください。）

また、省略して書くこともできます。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
print(scores[:3])  # 最初から3つ目まで
print(scores[2:])  # インデックス2から最後まで
print(scores[:])   # すべての要素
```

**出力：**
```bash
[85, 90, 78]
[78, 92, 88]
[85, 90, 78, 92, 88]
```

---

__ステップを指定して要素を取得する__

スライスには、**ステップ（何個おきに取得するか）** も指定できます。
ステップは、スライスの3番目の値 に指定します。

```python
リスト[開始:終了:ステップ]
```

例えば、2つおきに要素を取り出すには、次のように書きます。

**プログラム：**
```python
print(scores[::2])
```

**出力：**
```bash
[85, 75, 88]
```

マイナスのステップを指定すると、**逆順に取得** できます。

**プログラム：**
```python
print(scores[::-1]) 
```

**出力：**
```bash
[88, 92, 75, 80, 85]
```

---

__リスト要素の参照方法のまとめ__

| 操作 | 書き方 | 説明 |
| -- | -- | -- |
| 1つの要素を取得する | `scores[1]` | インデックス1の要素（2番目の要素）を取得 |
| 最後の要素を取得する | `scores[-1]` | 負のインデックスを使う |
| 一部の要素を取得する（スライス） | `scores[1:4]` | インデックス1以上4未満の要素を取得 |
| 先頭からスライス | `scores[:3]` | 最初からインデックス3未満まで |
| 途中からスライス | `scores[2:]` | インデックス2から最後まで |
| すべての要素を取得 | `scores[:]` | 全要素を取得 |
| 2つおきに取得 | `scores[::2]` | ステップを2にする |
| 逆順に取得 | `scores[::-1]` | 逆順のリストを取得 |

---

## 3. タプル

**タプル（Tuple）** は、リストとよく似たデータ構造ですが、一度作成すると要素を変更できないという特徴を持っています。
Pythonでは、カンマ区切りで `()` （丸括弧）を使ってタプルを作成します。

**プログラム：**
```python
fruits = ("apple", "banana", "cherry")
print(fruits)
```

**出力：**
```bash
('apple', 'banana', 'cherry')
```

### タプルの特徴

__1. 変更できない（イミュータブル）__

タプルの最大の特徴は、「作成後に要素を変更できない（追加・削除・変更ができない）」ことです。
リストとは異なり、タプルはデータの安全性を確保するために使われることが多いです。


**プログラム：**
```python
fruits = ("apple", "banana", "cherry")
fruits[0] = "grape" # エラー
```

**出力：**
```bash
---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

/var/folders/lc/k7jt3gx9283453ptp9t9ty5m0000gn/T/ipykernel_26027/2931223264.py in <module>
        1 fruits = ("apple", "banana", "cherry")
----> 2 fruits[0] = "grape" # エラー


TypeError: 'tuple' object does not support item assignment
```

---

__2. リストと同じようにインデックスでアクセスできる__

タプルの各要素には、リストと同じようにインデックスを使ってアクセスできます。

**プログラム：**
```python
fruits = ("apple", "banana", "cherry")
print(fruits[0])
print(fruits[1]) 
```

**出力：**
```bash
apple
banana
```

インデックスの仕組みもリストと同じで、負のインデックス `-1` を使うこともできます。

**プログラム：**
```python
print(fruits[-1]) 
```

**出力：**
```bash
cherry
```

---

__3. 複数のデータ型を含めることができる__

タプルの要素は、異なるデータ型を含めることが可能です。

**プログラム：**
```python
person = ("Alice", 30, True)
print(person)
```

**出力：**
```bash
('Alice', 30, True)
```

---

__4. 要素の個数を取得できる__

タプルの長さ（要素の数）は `len()` を使って取得できます。

**プログラム：**
```python
fruits = ("apple", "banana", "cherry")
print(len(fruits)) 
```

**出力：**
```bash
3
```

---

__5. 要素の検索（`in` を使用）__

タプルの中に特定の要素が含まれているかどうかを調べるには、`in` を使います。

**プログラム：**
```python
fruits = ("apple", "banana", "cherry")
print("banana" in fruits)
print("grape" in fruits)
```

**出力：**
```bash
True
False
```

---

__6. タプルの利点__

タプルには以下のような利点があります。

| **利点** | **説明** |
| -- | -- |
| **データの安全性** | 変更できないため、意図しないデータ変更を防げる |
| **メモリ効率が良い** | リストよりも軽量で、処理速度が速い場合がある |
| **辞書のキーとして使える** | イミュータブル（変更不可）なため、辞書のキーとして利用可能 |
| **プログラムの可読性向上** | 変更しないデータであることが明示でき、可読性が上がる |

---

__7. タプルの作成方法__

タプルの基本的な作成方法は、丸括弧 `()` を使うか、カンマ区切りで要素を記述するだけです。

**プログラム：**
```python
# 丸括弧を使う
numbers = (1, 2, 3, 4, 5)
print(numbers)

# カンマ区切りだけ（括弧なしでもOK）
colors = "red", "green", "blue"
print(colors)

# 1つの要素のタプル（カンマが必要）
single = ("apple",)  # カンマがないと単なる文字列と認識される
print(single)
```

**出力：**
```bash
(1, 2, 3, 4, 5)
('red', 'green', 'blue')
('apple',)
```

---

## 4. セット

**セット（Set）** は、重複する要素を持たない という特徴を持つデータ構造です。
数学の「集合」と同じように扱うことができ、重複したデータを自動的に削除する便利な機能を持っています。

Pythonでは、波括弧 `{}` を使ってセットを作成します。

セットは、リストやタプルとは異なり要素の順序を保持しないため、表示順が変わることがあります。

**プログラム：**
```python
fruits = {"apple", "banana", "cherry"}
print(fruits) 
```

**出力：**
```bash
{'apple', 'cherry', 'banana'}
```

### セットの特徴

__1. 重複する要素を持たない__

セットに同じ値を複数入れても、自動的に1つだけになります。


**プログラム：**
```python
numbers = {1, 2, 2, 3, 4, 4, 5}
print(numbers) 
```

**出力：**
```bash
{1, 2, 3, 4, 5}
```

---

__2. 順序を保持しない__

セットの要素は、追加した順番通りに並ばない ため、インデックスを使った要素の参照ができません。

**プログラム：**
```python
fruits = {"apple", "banana", "cherry"}
print(fruits[0])  # エラー（
```

**出力：**
```bash
---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

/var/folders/lc/k7jt3gx9283453ptp9t9ty5m0000gn/T/ipykernel_26027/3039682563.py in <module>
        1 fruits = {"apple", "banana", "cherry"}
----> 2 print(fruits[0])  # エラー（


TypeError: 'set' object is not subscriptable
```

---

__3. 集合演算（和・積・差）ができる__

セットは数学の集合と同じように、和集合・積集合・差集合 の演算が可能です。

**プログラム：**
```python
A = {1, 2, 3, 4}
B = {3, 4, 5, 6}

# 和集合（A ∪ B）
print(A | B)

# 積集合（A ∩ B）
print(A & B)

# 差集合（A - B）
print(A - B)

# 対称差集合（A △ B）
print(A ^ B)
```

**出力：**
```bash
{1, 2, 3, 4, 5, 6}
{3, 4}
{1, 2}
{1, 2, 5, 6}
```

---

__4. 要素の追加・削除ができる__

セットには `add()` で要素を追加し、`remove()` や `discard()` で要素を削除できます。


**プログラム：**
```python
fruits = {"apple", "banana"}
fruits.add("cherry")  # 要素を追加
print(fruits) 

fruits.remove("banana")  # 要素を削除
print(fruits) 
```

**出力：**
```bash
{'apple', 'cherry', 'banana'}
{'apple', 'cherry'}
```

---

__セットの作成方法__

セットを作る方法はいくつかあります。

__1. 波括弧 `{}` を使う__

```python
numbers = {1, 2, 3, 4, 5}
print(numbers)  # {1, 2, 3, 4, 5}
```

__2. set() を使う__

リストやタプルからセットを作成することもできます。

```python
list_numbers = [1, 2, 2, 3, 4]
set_numbers = set(list_numbers)
print(set_numbers)  # {1, 2, 3, 4}
```

!!! note "注意"
    空のセットを作るときは `{}` ではなく、`set()` を使います。 `{}` は空の辞書（ディクショナリ）として認識されます。

    ```python
    empty_set = set()  # 空のセット
    empty_dict = {}    # 空の辞書
    print(type(empty_set))  # <class 'set'>
    print(type(empty_dict))  # <class 'dict'>
    ```

---

### 集合演算

Pythonの `set（セット）`は、集合を扱うためのデータ構造です。
セットを使うと、数学的な集合演算（和・積・差・対称差など）を簡単に実行できます。

__1. 集合の基本操作__

セット（`set`）は重複しない要素の集まりです。

```python
A = {1, 2, 3, 4, 5}
B = {3, 4, 5, 6, 7}

print(A)  # {1, 2, 3, 4, 5}
print(B)  # {3, 4, 5, 6, 7}
```

__2. 集合演算の種類__

| **演算の種類** | **記号** | **メソッド** | **意味** |
| -- | -- | -- | -- |
| **和集合** | `A | B` | `A.union(B)` | AとBのすべての要素（重複なし） |
| **積集合** | `A & B` | `A.intersection(B)` | AとBの共通する要素 |
| **差集合** | `A - B` | `A.difference(B)` | AにあってBにない要素 |
| **対称差** | `A ^ B` | `A.symmetric_difference(B)` | AとBのどちらか一方にある要素 |
| **部分集合** | `A <= B` | `A.issubset(B)` | AがBの一部であるか |
| **超集合** | `A >= B` | `A.issuperset(B)` | BがAを含んでいるか |

__3. 各演算の具体例__

__(1) 和集合（`union`）__

両方の集合の要素をすべて集め、重複を取り除く。

**プログラム：**
```python
A = {1, 2, 3, 4, 5}
B = {3, 4, 5, 6, 7}

print(A | B)
print(A.union(B))  
```

**出力：**
```bash
{1, 2, 3, 4, 5, 6, 7}
{1, 2, 3, 4, 5, 6, 7}
```

__(2) 積集合（`intersection`）__

両方の集合に共通する要素のみを取り出す。

**プログラム：**
```python
print(A & B)
print(A.intersection(B))
```

**出力：**
```bash
{3, 4, 5}
{3, 4, 5}
```

__(3) 差集合（`difference`）__

片方の集合にあって、もう片方の集合にはない要素を取り出す。

**プログラム：**
```python
print(A - B)
print(A.difference(B))

print(B - A)
print(B.difference(A))
```

**出力：**
```bash
{1, 2}
{1, 2}
{6, 7}
{6, 7}
```

__(4) 対称差（`symmetric difference`）__

片方の集合にだけある要素を取り出す（共通部分を除く）。

**プログラム：**
```python
print(A ^ B)
print(A.symmetric_difference(B)) 
```

**出力：**
```bash
{1, 2, 6, 7}
{1, 2, 6, 7}
```

---

__4. 集合演算の応用__

__(1) 重複を削除__

リストから重複を削除するには、`set()` を使う。

**プログラム：**
```python
numbers = [1, 2, 2, 3, 4, 4, 5, 5, 6]
unique_numbers = set(numbers)

print(unique_numbers)
```

**出力：**
```python
{1, 2, 3, 4, 5, 6}
```

__(2) 部分集合（`subset`）と超集合（`superset`）__

ある集合が別の集合の一部かどうかを判定する。

**プログラム：**
```python
A = {1, 2, 3}
B = {1, 2, 3, 4, 5}

print(A <= B)   # True（AはBの部分集合）
print(A.issubset(B))

print(B >= A)   # True（BはAの超集合）
print(B.issuperset(A)) 
```

**出力：**
```bash
True
True
True
True
```
