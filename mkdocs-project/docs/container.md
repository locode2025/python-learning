# コンテナ

---

## 1. 変数が持つ不便さ

プログラムを作る上で「変数」は非常に重要な概念です。変数を使うことで、数値や文字列を一時的に記憶し、必要に応じて計算や処理を行えます。

例えば、次のように **score1** や **score2** に数値を入れ、合計を計算できます。

**プログラム：**
```python
score1 = 85
score2 = 90
total = score1 + score2
print(total)
```

**出力：**
```bash
175
```

このように、変数を使えば値を保存し、計算に活用できます。

__変数の不便な点__

しかし、プログラムが複雑になると、変数だけでデータを扱うのは大変になります。例えば、次のように10人分のテストの点数を管理する場合を考えましょう。

```python
score1 = 85
score2 = 90
score3 = 78
score4 = 92
score5 = 88
score6 = 76
score7 = 95
score8 = 89
score9 = 84
score10 = 91
```

この状態では、「10人以上になったらどうするのか？」 「全員の平均点を求めるとき、どう計算するのか？」 という問題が発生します。

変数だけでデータを管理するのは手間がかかり、拡張性に乏しいのです。

__もっと便利な方法とは？__

そこで登場するのが、「データの集まり（コンテナ）」です。Pythonには、**リスト**、**ディクショナリ**、**タプル**、**セット** という便利なデータ構造が用意されています。

例えば、リストを使うと、先ほどの10人分のスコアを簡単に管理できます。そして、リストを使えば、平均点も簡単に計算できます。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88, 76, 95, 89, 84, 91]
average = sum(scores) / len(scores)
print(average)
```

**出力：**
```bash
86.8
```

このように、データを「まとめて管理する」ことで、より柔軟で便利なプログラムが作れるようになります。

この章では、Pythonの「データの集まり（コンテナ）」について詳しく学んでいきましょう。

---

## 2. リスト

プログラムを作る上で、複数のデータをまとめて管理することは非常に重要です。Pythonでは、データの集まりを扱うために「リスト」というデータ構造が用意されています。

### リストの特徴

リストは、複数の値を順番に並べて格納できるデータ構造 です。
リストを使うことで、一つの変数で複数のデータをまとめて扱う ことができます。

例えば、10人分のテストの点数をリストで表すと、次のようになります。

```python
scores = [85, 90, 78, 92, 88, 76, 95, 89, 84, 91]
```

リストには次のような特徴があります。

!!! note "① 順番（インデックス）がある"

    リストのデータには「インデックス（index）」と呼ばれる番号が振られており、順番にアクセスできる ようになっています。
    Pythonのリストは **0から始まるインデックス** を持っています。

    | インデックス | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
    | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
    | 値（スコア）| 85 | 90 | 78 | 92 | 88 | 76 | 95 | 89 | 84 | 91 |

    例えば、1番目のスコア（**85**）を取得するには、`scores[0]` を使います。

    **プログラム：**
    ```python
    print(scores[0])
    ```

    **出力：**
    ```bash
    85
    ```

!!! note "② 異なるデータ型を混ぜて格納できる"

    リストには、整数・小数・文字列など、異なるデータ型を混ぜて格納することが可能 です。

    ```python
    data = [100, "Python", 3.14, True]
    ```

!!! note "③ 要素の追加・変更・削除ができる"

    リストは、一度作成した後でも、データの追加・変更・削除が可能 です。
    例えば、新しいスコアを追加したり、既存のスコアを変更したりできます。

では、リストの作成方法について詳しく解説していきます。

---

### リストの作成

__1. リストを作る基本的な方法__

実際にリストを作成する方法を詳しく見ていきましょう。リストを作るには、角かっこ（`[]`）を使って、データをカンマ（`,`）で区切って並べる だけです。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
print(scores)
```

**出力：**
```bash
[85, 90, 78, 92, 88]
```

---

__2. 空のリストを作る方法__

最初は中身がないリストを作って、あとからデータを追加したい場合もあります。
その場合は、空の角かっこ `[]` を使う か、`list()` を使います。

```python
empty_list1 = []  # 空のリスト
empty_list2 = list()  # こちらも空のリスト

print(empty_list1)  # []
print(empty_list2)  # []
```

どちらの方法でも、「最初はデータが空のリスト」を作成できる ので、状況に応じて使い分けましょう。

---

__3. 異なるデータ型を混ぜたリスト__

リストには、整数（**int**）、小数（**float**）、文字列（**str**）、真偽値（**bool**）など、さまざまなデータ型を混ぜて入れることができます。

**プログラム：**
```python
data = [100, "Python", 3.14, True]
print(data)
```

**出力：**
```bash
[100, 'Python', 3.14, True]
```

---

__3. `range()` を使ってリストを作る__

Pythonには、連続した数値を簡単にリストにする方法 があります。
それが `range()` という関数を使う方法です。

例えば、1から10までの数値をリストにするには、次のように書きます。

**プログラム：**
```python
numbers = list(range(1, 11))
print(numbers)
```

**出力：**
```bash
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

この `range(1, 11)` は、**「1 から 10 までの数値」** を順番に生成し、それを `list()` でリストに変換しています。

---

__リストの作成まとめ__

リストの作成方法には、次のようなものがあります。

| 方法 | 例 | 説明 |
| -- | -- | -- |
| 普通のリストを作る | `[85, 90, 78]` | 角かっこ `[]` を使う |
| 空のリストを作る | `[]` または `list()` | 最初にデータを入れない |
| 異なるデータ型を入れる | `[100, "Python", 3.14]` | 文字や数値を混ぜられる |
| `range()` を使う | `list(range(1, 6))` | 連続した数値のリスト |

このように、Pythonのリストは柔軟にデータを扱うことができます。

---

### リストの要素を参照

今回は、**リストの中のデータ（要素）を取り出す方法** を詳しく解説していきます。

__インデックスを使って要素を取り出す__

リストの要素を参照（取得）するには、**インデックス（index）** を使います。
Pythonのリストは、**0番目から順番に番号が振られている** ことを思い出しましょう。

例えば、以下のリストを考えます。

```python
scores = [85, 90, 78, 92, 88]
```

このリストは、次のようにインデックスが振られています。

| インデックス | 0  | 1  | 2  | 3  | 4  |
|-------------|----|----|----|----|----|
| 値（スコア）| 85 | 90 | 78 | 92 | 88 |

例えば、**2番目のスコア（インデックス1）を取得** するには、`scores[1]` と書きます。

**プログラム：**
```python
print(scores[1])
```

**出力：**
```bash
90
```

---

### リストの要素の合計と要素数の取得

今回は、リストの合計や要素数（長さ） を取得する方法を解説していきます。

__リストの要素の合計を求める__

Pythonでは、`sum()` 関数を使ってリスト内の数値の合計を求めることができます。

例えば、以下のリストの合計を計算してみましょう。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
total = sum(scores)
print(total)
```

**出力：**
```bash
433
```

---

__リストの要素数（長さ）を求める__

リストの要素数（長さ）を求めるには、`len()` 関数を使います。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
count = len(scores)
print(count)
```

**出力：**
```bash
5
```

---

__平均値を求める__

合計と要素数が分かれば、平均値も計算できます。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
average = sum(scores) / len(scores) 
print(average)
```

**出力：**
```bash
86.6
```

Pythonでは、リストの数値を使って簡単に統計的な計算ができます。
例えば、最大値や最小値も `max()` や `min()` を使って取得できます。

---

__リストの要素に対する演算のまとめ__

| 操作 | 書き方 | 説明 |
| -- | -- | -- |
| 合計を求める | `sum(scores)`  | リストの要素の合計を計算 |
| 要素数を求める | `len(scores)` | リストの要素の数（長さ）を取得 |
| 平均値を求める |  `sum(scores) / len(scores)` | 合計を要素数で割る |
| 最大値を求める | `max(scores)` | リスト内の最大値を取得 |
| 最小値を求める | `min(scores)` | リスト内の最小値を取得 |

---

### リスト要素の追加・削除・変更

リストに要素を追加・削除・変更する方法 を解説していきます。

__リストに要素を追加する__

リストに新しい要素を追加するには、`append()` や `insert()` を使います。

!!! note "`append()` で末尾に追加"
    `append()` を使うと、リストの最後 に新しい要素を追加できます。

**プログラム：**
```python
scores = [85, 90, 78]
scores.append(92)
print(scores)
```

**出力：**
```bash
[85, 90, 78, 92]
```


!!! note "`insert()` で指定位置に追加"
    `insert(位置, 値)` を使うと、リストの途中 に要素を挿入できます。

**プログラム：**
```python
scores = [85, 90, 78]
scores.insert(1, 88)
print(scores)
```

**出力：**
```bash
[85, 88, 90, 78]
```

---

__リストの要素を削除する__

リストの要素を削除する方法はいくつかあります。

!!! note "`pop()` で要素を取り出す"
    `pop()` は、リストの末尾の要素 を取り出して削除します。

**プログラム：**
```python
scores = [85, 90, 78]
last_score = scores.pop()
print(scores)
print(last_score)
```

**出力：**
```bash
[85, 90]
78
```

指定した位置 の要素を削除することもできます。

**プログラム**
```python
scores = [85, 90, 78]
scores.pop(1)
print(scores)
```

**出力：**
```bash
[85, 78]
```

!!! note "`remove()` で指定の値を削除"
    `remove(値)` を使うと、指定した値を削除 できます。※ 同じ値が複数ある場合、最初に見つかったものだけ 削除されるので注意しましょう。

**プログラム：**
```python
scores = [85, 90, 78, 90]
scores.remove(90)
print(scores)
```

**出力：**
```bash
[85, 78, 90]
```

!!! note "`del` を使う"
    `del` を使うと、特定の要素を削除できます。

**プログラム：**
```python
scores = [85, 90, 78]
del scores[1]
print(scores)
```

**出力：**
```python
[85, 78]
```

---

__リストの要素を変更する__

リストの要素は、インデックスを指定して書き換える ことができます。

**プログラム：**
```python
scores = [85, 90, 78]
scores[1] = 88
print(scores)
```

**出力：**
```bash
[85, 88, 78]
```

複数の要素をまとめて変更することも可能です。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
scores[1:3] = [80, 75]
print(scores)
```

**出力：**
```bash
[85, 80, 75, 92, 88]
```

---

__リストの要素に対する追加・変更・削除のまとめ__

| 操作 | 書き方 | 説明 |
| -- | -- | -- |
| 要素を末尾に追加 | `scores.append(92)` | リストの最後に要素を追加 |
| 指定位置に追加 | `scores.insert(1, 88)` | インデックス1に88を挿入 |
| 末尾の要素を削除 | `scores.pop()` | 最後の要素を取り出して削除 |
| 指定位置の要素を削除 | `scores.pop(1)` | インデックス1の要素を削除 |
| 指定の値を削除 | `scores.remove(90)` | 最初に見つかった90を削除 |
| 指定の要素を削除 | `del scores[1]` | インデックス1の要素を削除 |
| 要素を変更 | `scores[1] = 88` | インデックス1の値を88に変更 |
| 複数の要素を変更 | `scores[1:3] = [80, 75]` | インデックス1～2の要素を変更 |

---

### 高度な要素の指定

__マイナスのインデックスを使う__

Pythonのリストでは、負のインデックス（マイナスの番号）を使って、後ろから要素を取得する こともできます。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
print(scores[-1])
print(scores[-2])
```

**出力：**
```bash
88
92
```

マイナスのインデックスを使うと、リストの長さが分からなくても最後の要素を簡単に取得できる ので便利です。

| インデックス | -5 | -4 | -3 | -2 | -1 |
| -- | -- | -- | -- | -- | -- |
| 値（スコア）| 85 | 90 | 78 | 92 | 88 |

---

__範囲を指定して複数の要素を取得する（スライス）__

**スライス（slice）** を使うと、リストの一部をまとめて取得できます。
スライスの書き方は、以下のようになります。

```python
リスト[開始インデックス:終了インデックス]
```

例を見てみましょう。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
print(scores[1:4])
```

**出力：**
```bash
[90, 78, 92]
```

これは、**インデックス1から3までの要素を取り出す** という意味です。
（終了インデックス（4） は含まれず、**1以上4未満** の範囲になる点に注意してください。）

また、省略して書くこともできます。

**プログラム：**
```python
scores = [85, 90, 78, 92, 88]
print(scores[:3])  # 最初から3つ目まで
print(scores[2:])  # インデックス2から最後まで
print(scores[:])   # すべての要素
```

**出力：**
```bash
[85, 90, 78]
[78, 92, 88]
[85, 90, 78, 92, 88]
```

---

__ステップを指定して要素を取得する__

スライスには、**ステップ（何個おきに取得するか）** も指定できます。
ステップは、スライスの3番目の値 に指定します。

```python
リスト[開始:終了:ステップ]
```

例えば、2つおきに要素を取り出すには、次のように書きます。

**プログラム：**
```python
print(scores[::2])
```

**出力：**
```bash
[85, 75, 88]
```

マイナスのステップを指定すると、**逆順に取得** できます。

**プログラム：**
```python
print(scores[::-1]) 
```

**出力：**
```bash
[88, 92, 75, 80, 85]
```

---

__リスト要素の参照方法のまとめ__

| 操作 | 書き方 | 説明 |
| -- | -- | -- |
| 1つの要素を取得する | `scores[1]` | インデックス1の要素（2番目の要素）を取得 |
| 最後の要素を取得する | `scores[-1]` | 負のインデックスを使う |
| 一部の要素を取得する（スライス） | `scores[1:4]` | インデックス1以上4未満の要素を取得 |
| 先頭からスライス | `scores[:3]` | 最初からインデックス3未満まで |
| 途中からスライス | `scores[2:]` | インデックス2から最後まで |
| すべての要素を取得 | `scores[:]` | 全要素を取得 |
| 2つおきに取得 | `scores[::2]` | ステップを2にする |
| 逆順に取得 | `scores[::-1]` | 逆順のリストを取得 |

---

## 3. ディクショナリ

ディクショナリ（**辞書型**）は、キーと値のペアを格納するデータ構造です。
リストがインデックスで要素を管理するのに対して、ディクショナリは**任意のキー**（数値、文字列など）を使って、対応する値を格納します。

!!! note "ディクショナリの特徴"

    ディクショナリは、キーと値のペアを管理するため、リストやタプルとは異なる特徴を持っています。

    - 順序は保証されない（Python 3.7以降は挿入順序が保持されますが、基本的に順序に依存しません）
    - キーはユニークでなければならない
    - 値は任意のデータ型（文字列、リスト、数値など）を格納できます

### ディクショナリの作成

__基本的なディクショナリの作成__

ディクショナリは波括弧 `{}` を使って作成します。
また、キーと値はコロン `:` で区切り、複数のペアはコンマ `,` で区切ります。

例えば、以下のように`name`というキーに対して`"Alice"`という値を設定することができます。`"name"`, `"age"`, `"city"` がキーで、`"Alice"`, `30`, `"Tokyo"` がそれぞれ対応する値です。

**プログラム：**
```python
person = {"name": "Alice", "age": 30, "city": "Tokyo"}
print(person)
```

**出力：**
```bash
{'name': 'Alice', 'age': 30, 'city': 'Tokyo'}
```

---

__空のディクショナリの作成__

空のディクショナリも簡単に作成できます。
空のディクショナリは、波括弧 `{}` を使って作成します。

**プログラム：**
```python
empty_dict = {}
print(empty_dict)
```

**出力：**
```bash
{}
```

ディクショナリに後から要素を追加することもできます。

**プログラム：**
```python
empty_dict["name"] = "Alice"
empty_dict["age"] = 30
print(empty_dict)
```

**出力：**
```bash
{'name': 'Alice', 'age': 30}
```

---

__`dict()` を使ってディクショナリを作成__

Pythonには `dict()` という関数もあり、これを使ってディクショナリを作成することもできます。
例えば、以下のようにキーと値をタプルとして渡してディクショナリを作成します。

**プログラム：**
```python
person = dict(name="Alice", age=30, city="Tokyo")
print(person)
```

**出力：**
```bash
{'name': 'Alice', 'age': 30, 'city': 'Tokyo'}
```

---

### ディクショナリの要素の参照

ディクショナリでは、キーを使って対応する値を参照できます。
リストと異なり、ディクショナリはインデックスではなくキーを使ってアクセスするため、非常に柔軟にデータを扱うことができます。
今回は、ディクショナリの要素を参照する方法について学びましょう。

__キーを使って値を取得する__

ディクショナリの要素にアクセスする最も基本的な方法は、キーを使うことです。
キーを指定して、対応する値を取得します。

**プログラム：**
```python
person = {
    "name": "Alice",
    "age": 30,
    "city": "Tokyo"
}

print(person["name"])
print(person["age"])
print(person["city"])
```

**出力：**
```bash
Alice
30
Tokyo
```

このように、`person["name"]` という形でキーを指定することで、対応する値を取得できます。
もし、指定したキーが存在しない場合は、KeyError が発生します。

**プログラム：**
```python
person = {
    "name": "Alice",
    "age": 30,
    "city": "Tokyo"
}

person['unknown']
```

**出力：**
```bash
---------------------------------------------------------------------------

KeyError                                  Traceback (most recent call last)

/var/folders/lc/k7jt3gx9283453ptp9t9ty5m0000gn/T/ipykernel_26027/3585071311.py in <module>
----> 1 person['unknown']


KeyError: 'unknown'
```

---

__`get()` メソッドを使って値を取得する__

`get()` メソッドを使うと、キーが存在しない場合でもエラーを防ぐことができます。
`get()` メソッドは、キーが見つかった場合は対応する値を返し、見つからなかった場合には指定したデフォルト値（省略すると None）を返します。

**プログラム：**
```python
person = {
    "name": "Alice",
    "age": 30,
    "city": "Tokyo"
}

print(person.get("name"))
print(person.get("address", "Not available"))
```

**出力：**
```bash
Alice
Not available
```

`person.get("name")` は、`"name"` に対応する値 `"Alice"` を返します。
`person.get("address", "Not available")` は、`"address"` キーがないため、デフォルトの `"Not available"` を返します。

---

__キーが存在するか確認する (`in` 演算子)__

ディクショナリのキーが存在するかどうかを確認するには、`in` 演算子を使います。
もし指定したキーがディクショナリに存在すれば `True` を、存在しなければ `False` を返します。
これを使えば、キーの存在確認を簡単に行うことができます。

**プログラム：**
```python
person = {
    "name": "Alice",
    "age": 30,
    "city": "Tokyo"
}

print("name" in person)
print("address" in person) 
```

**出力：**
```bash
True
False
```

---

__複数の要素を取得する（`items()` メソッド）__

ディクショナリには、キーと値のペアを全て取得するための `items()` メソッドがあります。
`items()` メソッドを使うと、ディクショナリ内のすべてのキーと値をタプルの形で取得できます。
次のように、`for` ループを使ってディクショナリ内のすべてのキーと値を順に参照できます。

**プログラム：**
```python
person = {
    "name": "Alice",
    "age": 30,
    "city": "Tokyo"
}

for key, value in person.items():
    print(key, value)
```

**出力：**
```bash
name Alice
age 30
city Tokyo
```

---

__キーのリストを取得する（`keys()` メソッド）__

`keys()` メソッドを使うと、ディクショナリ内のすべてのキーをリストとして取得することができます。
取得されるのは、`dict_keys` という特殊なオブジェクトですが、リストのように扱えます。

**プログラム：**
```python
person = {
    "name": "Alice",
    "age": 30,
    "city": "Tokyo"
}

print(person.keys())
print(type(person.keys()))
```

**出力：**
```bash
dict_keys(['name', 'age', 'city'])
<class 'dict_keys'>
```

---

__値のリストを取得する（`values()` メソッド）__

`values()` メソッドを使うと、ディクショナリ内のすべての値をリストとして取得することができます。
これも、`dict_values` というオブジェクトが返されますが、リストのように扱えます。


**プログラム：**
```python
person = {
    "name": "Alice",
    "age": 30,
    "city": "Tokyo"
}

print(person.values())
print(type(person.values()))
```

**出力：**
```bash
dict_values(['Alice', 30, 'Tokyo'])
<class 'dict_values'>
```

---

__ディクショナリの要素の参照方法のまとめ__

| 操作 | 書き方 | 説明 |
| -- | -- | -- |
| キーを使って値を取得 | `person["name"]` | キーを使って値を取得 |
| `get()` メソッドで値を取得 | `person.get("name")` | `get()` メソッドで値を取得（エラー回避）|
| キーが存在するか確認 (`in` 演算子) | `"name" in person` | キーが存在するか確認 |
| `items()` メソッドで複数の要素を取得 | `person.items()` | キーと値のペアを全て取得 |
| `keys()` メソッドでキーのリストを取得 | `person.keys() | ディクショナリのキーを取得 |
| `values()` メソッドで値のリストを取得 | `person.values()` | ディクショナリの値を取得 |

---

### ディクショナリの要素の追加と変更

ディクショナリに新しい要素を追加したり、既存の要素の値を変更する方法について解説します。
ディクショナリは、キーと値のペアを管理しているため、簡単に要素を追加・変更できます。

__要素の追加__

ディクショナリに要素を追加するには、新しいキーを指定し、そのキーに対応する値を代入します。
新しいキーを指定すると、そのキーと値のペアがディクショナリに追加されます。
次の例では、`person["city"] = "Tokyo"` という形で新しいキー `"city"` を追加しています。

**プログラム：**
```python
person = {
    "name": "Alice",
    "age": 30
}

person["city"] = "Tokyo"
print(person)
```

**出力：**
```bash
{'name': 'Alice', 'age': 30, 'city': 'Tokyo'}
```

---

__要素の変更__

ディクショナリの要素を変更するには、既存のキーを指定して新しい値を代入します。
もし指定したキーがすでに存在していれば、その値が新しい値に変更されます。
次の例では、`"age"` の値が `30` から `31` に変更されています。

**プログラム：**
```python
person = {
    "name": "Alice",
    "age": 30,
    "city": "Tokyo"
}

person["age"] = 31
print(person)
```

**出力；**
```bash
{'name': 'Alice', 'age': 31, 'city': 'Tokyo'}
```

---

__ディクショナリ内での更新（`update()` メソッド）__

複数の要素を同時に追加したり変更したりするには、`update()` メソッドを使います。
`update()` メソッドは、別のディクショナリやキーと値のペアを指定して、ディクショナリを更新することができます。

**プログラム：**
```python
person = {
    "name": "Alice",
    "age": 30
}

person.update({"city": "Tokyo", "age": 31})
print(person)
```

**出力：**
```bash
{'name': 'Alice', 'age': 31, 'city': 'Tokyo'}
```

---

### ディクショナリの要素の削除

ディクショナリから要素を削除する方法について解説します。
ディクショナリでは、キーを使ってそのキーに対応する値を削除できます。

__`del` を使った削除__

`del` を使うことで、指定したキーをディクショナリから削除することができます。
指定したキーが存在しない場合は、`KeyError` が発生します。
次の例では、`"city"` キーを削除しています。

**プログラム：**
```python
person = {
    "name": "Alice",
    "age": 30,
    "city": "Tokyo"
}

del person["city"]
print(person)
```

**出力：**
```bash
{'name': 'Alice', 'age': 30}
```

__`pop()` メソッドを使った削除__

`pop()` メソッドを使うことで、指定したキーに対応する値を削除すると同時に、その値を返すことができます。
`pop()` メソッドを使うと、削除した値を取得できるため、削除した値が必要な場合に便利です。
次の例では、`pop("age")` で `"age"` キーを削除し、削除した値 `30` を返しています。

**プログラム：**
```python
person = {
    "name": "Alice",
    "age": 30,
    "city": "Tokyo"
}

age = person.pop("age")

print(person)
print(age)
```

**出力：**
```bash
{'name': 'Alice', 'city': 'Tokyo'}
30
```

__`popitem()` メソッドを使った削除__

`popitem()` メソッドを使うと、ディクショナリから最後の要素（キーと値のペア）を削除することができます。
これも削除したペアを返します。
次の例では、ディクショナリの最後の要素（`"city": "Tokyo"`) を削除し、そのペアがタプルとして返されています。

**プログラム：**
```python
person = {
    "name": "Alice",
    "age": 30,
    "city": "Tokyo"
}

item = person.popitem()

print(person)
print(item)
```

**出力：**
```bash
{'name': 'Alice', 'age': 30}
('city', 'Tokyo')
```

---

### ディクショナリ要素の追加・変更・削除のまとめ

| 操作 | 書き方 | 説明 |
| -- | -- | -- |
| 要素の追加 | `person["city"] = "Tokyo"`| 新しいキーと値のペアを追加 |
| 要素の変更 | `person["age"] = 31` | 既存のキーの値を変更 |
| 複数の要素を追加・変更 | `person.update({"city": "Tokyo", "age": 31})` | update() メソッドで複数の要素を一度に変更・追加 |
| `del` を使った削除 | `del person["city"]` | 指定したキーと対応する値を削除 |
| `pop()` メソッドを使った削除 | `person.pop("age")` | 指定したキーを削除し、その値を返す |
| `popitem()` メソッドを使った削除 | `person.popitem()` | 最後の要素（キーと値のペア）を削除し、そのペアを返す |

## 4. ディクショナリとリストの比較
リストとディクショナリは、どちらもデータを格納するためのコンテナですが、それぞれの特徴にはいくつかの違いがあります。
ここでは、リストとディクショナリを比較し、それぞれの適した使い方を理解しましょう。

!!! note "1. データの格納方法"

    リストは、 インデックス（順番）を使ってデータを格納します。
    リストの要素は順番が重要で、インデックス番号（`0`, `1`, `2`, ...）でアクセスします。

    ディクショナリは、キーと値のペアでデータを格納します。
    ディクショナリではキーを使ってデータにアクセスしますが、順番は基本的に関係ありません（Python 3.7以降、挿入順序が保持されますが、それでも順番よりキーの意味が重要です）。

!!! note "2. データへのアクセス方法"

    リストは、インデックス番号を使って要素にアクセスします。
    インデックスは整数であり、順番に依存しています。

    ディクショナリは、キーを使って値にアクセスします。
    キーは任意の **不変の型（文字列、整数、タプルなど）** であり、順番に依存せず、キーで明示的に指定して値を取得します。

!!! note "3. データの順序"

    リストは、要素が順番通り格納されます。
    インデックス番号に基づいて要素が並べられているため、順番が重要です。

    ディクショナリは、Python 3.7以降、挿入順序は保持されますが、順番に依存しません。
    ディクショナリでは、キーによって値にアクセスするため、順番に意味を持たせることは少ないです。

!!! note "4. データの格納目的"

    リストは、順序付きのデータが必要な場合に適しています。
    同じ種類のデータを順番に格納したい場合に便利です。例えば、商品リストや名前のリストなど。

    ディクショナリは、キーを使って特定のデータを迅速に取り出したい場合に適しています。
    名前と年齢、IDと名前など、キーと値の対応を持つデータを扱いたい場合に使います。

!!! note "5. メモリ効率"

    リストは、順番に格納されたデータを扱うため、インデックスを使って要素にアクセスできますが、キーを使ってデータを探すことはできません。
    リストはメモリ的に効率的で、順番通りに要素を格納するシンプルなデータ構造です。

    ディクショナリは、キーと値のペアを格納するため、アクセスが高速ですが、キーに対するハッシュを使うため、リストよりもメモリを多く消費する場合があります。
    ディクショナリは、キーに基づいてデータを高速に検索できるため、大規模なデータに対して有効です。

__まとめ__

リストは、順序が重要なデータを扱うのに適しており、ディクショナリはキーと値の対応が重要なデータに適しています。それぞれの特徴を理解し、使い分けることで、より効果的にデータを管理できるようになります。
次の表を参考に、リストとディクショナリを使い分けてデータを管理する方法を理解しましょう。

| 特徴                   | リスト                          | ディクショナリ                    |
|:-|:-|:-|
| 1. データの格納方法       | 順番に格納、インデックスを使用     | キーと値のペア、キーを使用       |
| 2. データのアクセス方法   | インデックス番号を使用            | キーを使用                       |
| 3. データの順序           | 順番通り（インデックス順）         | 挿入順序（Python 3.7以降）       |
| 4. 使用目的               | 順序を保持したデータの管理          | キーと値のペアで特定のデータを管理 |
| 5. メモリ効率             | 効率的（順番通りのデータ）         | キーと値にハッシュテーブルを使用  |

## 5. タプルとセット

---

### タプル

**タプル（Tuple）** は、リストとよく似たデータ構造ですが、一度作成すると要素を変更できないという特徴を持っています。
Pythonでは、カンマ区切りで `()` （丸括弧）を使ってタプルを作成します。

**プログラム：**
```python
fruits = ("apple", "banana", "cherry")
print(fruits)
```

**出力：**
```bash
('apple', 'banana', 'cherry')
```

### タプルの特徴

__1. 変更できない（イミュータブル）__

タプルの最大の特徴は、「作成後に要素を変更できない（追加・削除・変更ができない）」ことです。
リストとは異なり、タプルはデータの安全性を確保するために使われることが多いです。


**プログラム：**
```python
fruits = ("apple", "banana", "cherry")
fruits[0] = "grape" # エラー
```

**出力：**
```bash
---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

/var/folders/lc/k7jt3gx9283453ptp9t9ty5m0000gn/T/ipykernel_26027/2931223264.py in <module>
        1 fruits = ("apple", "banana", "cherry")
----> 2 fruits[0] = "grape" # エラー


TypeError: 'tuple' object does not support item assignment
```

---

__2. リストと同じようにインデックスでアクセスできる__

タプルの各要素には、リストと同じようにインデックスを使ってアクセスできます。

**プログラム：**
```python
fruits = ("apple", "banana", "cherry")
print(fruits[0])
print(fruits[1]) 
```

**出力：**
```bash
apple
banana
```

インデックスの仕組みもリストと同じで、負のインデックス `-1` を使うこともできます。

**プログラム：**
```python
print(fruits[-1]) 
```

**出力：**
```bash
cherry
```

---

__3. 複数のデータ型を含めることができる__

タプルの要素は、異なるデータ型を含めることが可能です。

**プログラム：**
```python
person = ("Alice", 30, True)
print(person)
```

**出力：**
```bash
('Alice', 30, True)
```

---

__4. 要素の個数を取得できる__

タプルの長さ（要素の数）は `len()` を使って取得できます。

**プログラム：**
```python
fruits = ("apple", "banana", "cherry")
print(len(fruits)) 
```

**出力：**
```bash
3
```

---

__5. 要素の検索（`in` を使用）__

タプルの中に特定の要素が含まれているかどうかを調べるには、`in` を使います。

**プログラム：**
```python
fruits = ("apple", "banana", "cherry")
print("banana" in fruits)
print("grape" in fruits)
```

**出力：**
```bash
True
False
```

---

__6. タプルの利点__

タプルには以下のような利点があります。

| **利点** | **説明** |
| -- | -- |
| **データの安全性** | 変更できないため、意図しないデータ変更を防げる |
| **メモリ効率が良い** | リストよりも軽量で、処理速度が速い場合がある |
| **辞書のキーとして使える** | イミュータブル（変更不可）なため、辞書のキーとして利用可能 |
| **プログラムの可読性向上** | 変更しないデータであることが明示でき、可読性が上がる |

---

__7. タプルの作成方法__

タプルの基本的な作成方法は、丸括弧 `()` を使うか、カンマ区切りで要素を記述するだけです。


**プログラム：**
```python
# 丸括弧を使う
numbers = (1, 2, 3, 4, 5)
print(numbers)

# カンマ区切りだけ（括弧なしでもOK）
colors = "red", "green", "blue"
print(colors)

# 1つの要素のタプル（カンマが必要）
single = ("apple",)  # カンマがないと単なる文字列と認識される
print(single)
```

**出力：**
```bash
(1, 2, 3, 4, 5)
('red', 'green', 'blue')
('apple',)
```

---

### セット

**セット（Set）** は、重複する要素を持たない という特徴を持つデータ構造です。
数学の「集合」と同じように扱うことができ、重複したデータを自動的に削除する便利な機能を持っています。

Pythonでは、波括弧 `{}` を使ってセットを作成します。

セットは、リストやタプルとは異なり要素の順序を保持しないため、表示順が変わることがあります。

**プログラム：**
```python
fruits = {"apple", "banana", "cherry"}
print(fruits) 
```

**出力：**
```bash
{'apple', 'cherry', 'banana'}
```

### セットの特徴

__1. 重複する要素を持たない__

セットに同じ値を複数入れても、自動的に1つだけになります。


**プログラム：**
```python
numbers = {1, 2, 2, 3, 4, 4, 5}
print(numbers) 
```

**出力：**
```bash
{1, 2, 3, 4, 5}
```

---

__2. 順序を保持しない__

セットの要素は、追加した順番通りに並ばない ため、インデックスを使った要素の参照ができません。

**プログラム：**
```python
fruits = {"apple", "banana", "cherry"}
print(fruits[0])  # エラー（
```

**出力：**
```bash
---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

/var/folders/lc/k7jt3gx9283453ptp9t9ty5m0000gn/T/ipykernel_26027/3039682563.py in <module>
        1 fruits = {"apple", "banana", "cherry"}
----> 2 print(fruits[0])  # エラー（


TypeError: 'set' object is not subscriptable
```

---

__3. 集合演算（和・積・差）ができる__

セットは数学の集合と同じように、和集合・積集合・差集合 の演算が可能です。

**プログラム：**
```python
A = {1, 2, 3, 4}
B = {3, 4, 5, 6}

# 和集合（A ∪ B）
print(A | B)

# 積集合（A ∩ B）
print(A & B)

# 差集合（A - B）
print(A - B)

# 対称差集合（A △ B）
print(A ^ B)
```

**出力：**
```bash
{1, 2, 3, 4, 5, 6}
{3, 4}
{1, 2}
{1, 2, 5, 6}
```

---

__4. 要素の追加・削除ができる__

セットには `add()` で要素を追加し、`remove()` や `discard()` で要素を削除できます。


**プログラム：**
```python
fruits = {"apple", "banana"}
fruits.add("cherry")  # 要素を追加
print(fruits) 

fruits.remove("banana")  # 要素を削除
print(fruits) 
```

**出力：**
```bash
{'apple', 'cherry', 'banana'}
{'apple', 'cherry'}
```

---

__セットの作成方法__

セットを作る方法はいくつかあります。

__1. 波括弧 `{}` を使う__

```python
numbers = {1, 2, 3, 4, 5}
print(numbers)  # {1, 2, 3, 4, 5}
```

__2. set() を使う__

リストやタプルからセットを作成することもできます。

```python
list_numbers = [1, 2, 2, 3, 4]
set_numbers = set(list_numbers)
print(set_numbers)  # {1, 2, 3, 4}
```

!!! note "注意"
    空のセットを作るときは `{}` ではなく、`set()` を使います。 `{}` は空の辞書（ディクショナリ）として認識されます。

    ```python
    empty_set = set()  # 空のセット
    empty_dict = {}    # 空の辞書
    print(type(empty_set))  # <class 'set'>
    print(type(empty_dict))  # <class 'dict'>
    ```

---

## 5. コンテナの応用

### コンテナの相互変換

Pythonでは、リスト（`list`）、タプル（`tuple`）、セット（`set`）、ディクショナリ（`dict`） などのコンテナ同士を相互に変換することができます。
データの特性に応じて適切なコンテナを選択し、柔軟に使い分けるために重要なテクニックです。

---

__1. リスト ⇔ タプル の変換__

リストとタプルは、`list()` や `tuple()` を使って簡単に変換できます。

使い分け：

- リスト は変更可能（ミュータブル）で、データの追加・削除ができる
- タプル は変更不可（イミュータブル）で、安全性が高い

**プログラム：**
```python
# リスト → タプル
numbers_list = [1, 2, 3]
numbers_tuple = tuple(numbers_list)
print(numbers_tuple)

# タプル → リスト
numbers_tuple = (4, 5, 6)
numbers_list = list(numbers_tuple)
print(numbers_list)
```

**出力：**
```bash
(1, 2, 3)
[4, 5, 6]
```

---

__2. リスト ⇔ セット の変換__

セットに変換すると重複が自動的に削除されます。

使い分け:

- リスト は順序を保持するが、重複を許す
- セット は順序を保持しないが、重複を削除する

**プログラム：**
```python
# リスト → セット（重複削除）
numbers_list = [1, 2, 2, 3, 4, 4, 5]
numbers_set = set(numbers_list)
print(numbers_set)

# セット → リスト（順序がなくなる可能性あり）
numbers_list = list(numbers_set)
print(numbers_list) 
```

**出力：**
```bash
{1, 2, 3, 4, 5}
[1, 2, 3, 4, 5]
```

---

__3. リスト ⇔ ディクショナリ の変換__

リストとディクショナリは構造が異なるため、リストをキーと値のペアに変換する必要があります。

使い分け:

- リスト は単純なデータの並びに適している
- ディクショナリ はキーと値の関係を管理するのに適している


**プログラム：**
```python
# リスト（タプルのリスト） → ディクショナリ
pairs = [("apple", 100), ("banana", 200), ("cherry", 300)]
fruits_dict = dict(pairs)
print(fruits_dict)

# ディクショナリ → リスト（キーや値のリストに）
keys_list = list(fruits_dict.keys())
values_list = list(fruits_dict.values())

print(keys_list)
print(values_list)
```

**出力：**
```bash
{'apple': 100, 'banana': 200, 'cherry': 300}
['apple', 'banana', 'cherry']
[100, 200, 300]
```

---

__コンテナの相互変換のまとめ__

コンテナの相互変換を活用することで、データを適切な形に整え、効率的に処理できます。

| **変換元** → **変換先** | **変換方法** |
|:-|:-:|
| リスト → タプル | `tuple(list_data)` |
| タプル → リスト | `list(tuple_data)` |
| リスト → セット | `set(list_data)` |
| セット → リスト | `list(set_data)` |
| リスト → 辞書 | `dict(list_of_tuples)` |
| 辞書 → リスト（キー） | `list(dict.keys())` |
| 辞書 → リスト（値） | `list(dict.values())` |

---

### コンテナのネスト

コンテナのネスト（入れ子） とは、リストの中にリストを入れる、ディクショナリの中にリストを入れる など、
異なるデータ構造を組み合わせて使うことを指します。
ネストを活用することで、より複雑なデータを整理・管理しやすくなります。

__1. リストのネスト__

リストの中にリストを含めると、2次元リスト（リストのリスト） を作ることができます。

**プログラム：**
```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print(matrix[0])
print(matrix[0][1])
```

**出力：**
```bash
[1, 2, 3]
2
```

!!! note "応用"
    リストのリストを使うことで、表（テーブル）データ を扱えます。

    ```python
    students = [
        ["Alice", 85, 90, 88], 
        ["Bob", 78, 92, 80], 
        ["Charlie", 90, 85, 95]
    ]

    # Bobの2つ目の点数を取得
    print(students[1][2])  # 92
    ```

---

__2. ディクショナリのネスト__

ディクショナリの中にリストや別のディクショナリを入れることで、
データをより意味のある形で整理 できます。

**プログラム：**
```python
student_scores = {
    "Alice": {"math": 85, "english": 90, "science": 88},
    "Bob": {"math": 78, "english": 92, "science": 80},
    "Charlie": {"math": 90, "english": 85, "science": 95}
}

print(student_scores["Bob"]["english"])
```

**出力：**
```bash
92
```

!!! note "応用"
    辞書をリストに入れることで、複数のデータを扱いやすく なります。

    ```python
    employees = [
        {"name": "Alice", "age": 25, "department": "HR"},
        {"name": "Bob", "age": 30, "department": "IT"},
        {"name": "Charlie", "age": 28, "department": "Finance"}
    ]

    # Bobの部署を取得
    print(employees[1]["department"])  # IT
    ```

__3. セットのネスト__

セットはネストできない（リストや辞書のように入れ子にできない）ため、
セットの中にセットを入れることはできません。セットは「変更できない（ミュータブル）データ型」を要素として持てないため、セットの中にセットを入れることは不可能となっています

**プログラム：**
```python
set_a = {1, 2, {3, 4}}  # エラー
```

**出力：**
```bash
---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

/var/folders/lc/k7jt3gx9283453ptp9t9ty5m0000gn/T/ipykernel_26027/1420277885.py in <module>
----> 1 set_a = {1, 2, {3, 4}}  # エラー


TypeError: unhashable type: 'set'
```

---

__4. ネストしたデータのアクセス__

ネストしたコンテナのデータにアクセスするときは、インデックスやキーを順に指定 します。

**プログラム：**
```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
print(matrix[1][2])

student_scores = {
    "Alice": {"math": 85, "english": 90},
    "Bob": {"math": 78, "english": 92}
}
print(student_scores["Alice"]["math"])
```

**出力：**
```bash
6
85
```

### 集合演算

Pythonの `set（セット）`は、集合を扱うためのデータ構造です。
セットを使うと、数学的な集合演算（和・積・差・対称差など）を簡単に実行できます。

__1. 集合の基本操作__

セット（`set`）は重複しない要素の集まりです。

```python
A = {1, 2, 3, 4, 5}
B = {3, 4, 5, 6, 7}

print(A)  # {1, 2, 3, 4, 5}
print(B)  # {3, 4, 5, 6, 7}
```

__2. 集合演算の種類__

| **演算の種類** | **記号** | **メソッド** | **意味** |
| -- | -- | -- | -- |
| **和集合** | `A | B` | `A.union(B)` | AとBのすべての要素（重複なし） |
| **積集合** | `A & B` | `A.intersection(B)` | AとBの共通する要素 |
| **差集合** | `A - B` | `A.difference(B)` | AにあってBにない要素 |
| **対称差** | `A ^ B` | `A.symmetric_difference(B)` | AとBのどちらか一方にある要素 |
| **部分集合** | `A <= B` | `A.issubset(B)` | AがBの一部であるか |
| **超集合** | `A >= B` | `A.issuperset(B)` | BがAを含んでいるか |

---

__3. 各演算の具体例__

__(1) 和集合（`union`）__

両方の集合の要素をすべて集め、重複を取り除く。

**プログラム：**
```python
A = {1, 2, 3, 4, 5}
B = {3, 4, 5, 6, 7}

print(A | B)
print(A.union(B))  
```

**出力：**
```bash
{1, 2, 3, 4, 5, 6, 7}
{1, 2, 3, 4, 5, 6, 7}
```

__(2) 積集合（`intersection`）__

両方の集合に共通する要素のみを取り出す。

**プログラム：**
```python
print(A & B)
print(A.intersection(B))
```

**出力：**
```bash
{3, 4, 5}
{3, 4, 5}
```

__(3) 差集合（`difference`）__

片方の集合にあって、もう片方の集合にはない要素を取り出す。

**プログラム：**
```python
print(A - B)
print(A.difference(B))

print(B - A)
print(B.difference(A))
```

**出力：**
```bash
{1, 2}
{1, 2}
{6, 7}
{6, 7}
```

__(4) 対称差（`symmetric difference`）__

片方の集合にだけある要素を取り出す（共通部分を除く）。

**プログラム：**
```python
print(A ^ B)
print(A.symmetric_difference(B)) 
```

**出力：**
```bash
{1, 2, 6, 7}
{1, 2, 6, 7}
```

---

__4. 集合演算の応用__

__(1) 重複を削除__

リストから重複を削除するには、`set()` を使う。

**プログラム：**
```python
numbers = [1, 2, 2, 3, 4, 4, 5, 5, 6]
unique_numbers = set(numbers)

print(unique_numbers)
```

**出力：**
```python
{1, 2, 3, 4, 5, 6}
```

__(2) 部分集合（`subset`）と超集合（`superset`）__

ある集合が別の集合の一部かどうかを判定する。

**プログラム：**
```python
A = {1, 2, 3}
B = {1, 2, 3, 4, 5}

print(A <= B)   # True（AはBの部分集合）
print(A.issubset(B))

print(B >= A)   # True（BはAの超集合）
print(B.issuperset(A)) 
```

**出力：**
```bash
True
True
True
True
```

### 集合演算のまとめ

| **演算** | **方法（記号）** | **方法（メソッド）** | **説明** |
|:-:|:-:|:-:|:-|
| **和集合** | `A | B` | `A.union(B)` | AとBのすべての要素（重複なし） |
| **積集合** | `A & B` | `A.intersection(B)` | AとBの共通する要素 |
| **差集合** | `A - B` | `A.difference(B)` | AにあってBにない要素 |
| **対称差** | `A ^ B` | `A.symmetric_difference(B)` | AまたはBのみにある要素 |
| **部分集合** | `A <= B` | `A.issubset(B)` | AがBの一部であるか |
| **超集合** | `A >= B` | `A.issuperset(B)` | BがAを含んでいるか |

---

## この章のまとめ

本章では、データを整理・管理するための「コンテナ」について学びました。

!!! success "1. 変数が持つ不便さ"

    - 変数は1つの値しか保持できず、多くのデータを扱うのに不便。
    - より効率的なデータ管理のために「リスト」「ディクショナリ」「タプル」「セット」といったコンテナを活用する。

!!! success "2. リスト"

    - 特徴: 複数の要素を順番に保持でき、変更が可能。
    - 作成: `[]` を使ってリストを作成。
    - 要素の参照: インデックスを使ってアクセス。
    - 合計と要素数の取得: `sum()` や `len()` を利用。
    - 追加・削除・変更: `append()`, `remove()`,` insert()` などのメソッドを使用。
    - 高度な指定: スライスで部分的に取り出しや更新が可能。

!!! success "3. ディクショナリ"

    - 特徴: キーと値のペアでデータを管理し、高速にアクセス可能。
    - 作成: `{}` を使ってキーと値を定義。
    - 要素の参照: `dict[key]` で値を取得。
    - 追加・変更: `dict[key] = value` で設定。
    - 削除: `del dict[key]` で削除。
    - リストとの比較: ディクショナリはキーを利用するため、リストよりも検索が高速な場合がある。

!!! success "4. タプルとセット"

    - タプル: `()` で定義し、変更不可（イミュータブル）。リストより安全にデータを保持できる。
    - セット: `{}` で定義し、重複を許さない。集合演算が可能。

!!! success "5. コンテナの応用"

    - 相互変換: `list()`, `tuple()`, `set()`, `dict()` を使ってコンテナ間の変換が可能。
    - ネスト: コンテナの中に別のコンテナを入れることで複雑なデータ構造を管理。

これらのコンテナを適切に活用することで、プログラムのデータ管理がより柔軟かつ効率的になります。

---

👉 [次の章では、**条件分岐** について学び、より実用的なプログラムを作成していきましょう！](../conditinal_statement)